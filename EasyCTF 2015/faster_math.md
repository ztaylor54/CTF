#Faster Math
I need help on my homework! Connect to `programming.easyctf.com:10300` where a series of 100 problems await you.

##Hint:
There's only 4 types of problems. You can do it :) If you're having difficulty with the time limit, try running it on the shell server. Its internet should be pretty fast.

If you'd like, post your favorite, wackiest autogenerated problems to [@easyctf](http://twitter.com/easyctf)!

##Solution:
If we connect to `programming.easyctf.com:10300` enough times, we see the 4 types of problems:

1. Fill in the missing operators
2. Find the distance an object travels after it is projected
3. How many ways can you use change to make a target value
4. Find the lower or higher root of a quadratic function

We can solve this problem using an INET streaming socket connection in Python. This will be fast enough to solve all 100 problems within the 30 second time constraint.

Here's the script, it's a bit lengthy:
```python
import socket
import random
import math
import re
 
hostname = 'programming.easyctf.com'
port = 10300
 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((hostname, port))
attempts = 0
for i in range(1, 101, 1):
    for j in range(1, 100, 1):
        print(s.recv(1024))
        rec = s.recv(1024)
        print(rec)
        answer = ""
        if "the operations (+, -, or x)" in rec:
            rec=rec.replace("(","s")
            rec=rec.replace(")","e")
            a = int(str(rec[(rec.index("sss")+len("sss")):rec.index(" _ ")]))
            b = int(str(rec[(rec.index(" _ ")+len(" _ ")):rec.index("e _ ")]))
            rec = rec.replace("e _ ","LOLWUT",1)
            c = int(str(rec[(rec.index("LOLWUT")+len("LOLWUT")):rec.index("e _ ")]))
            d = int(str(rec[(rec.index("e _ ")+len("e _ ")):rec.index("e = ")]))
            e = int(str(rec[(rec.index("e = ")+len("e = ")):len(rec)]))
            #print("a: " + str(a) + " b: " + str(b) + " c: " + str(c)  + " d: " + str(d)  + " e: " + str(e) )
            operators = ["+", "-", "x"]
            for i in range(0,3):
                for j in range(0,3):
                    for k in range(0,3):
                        if i == 0:
                            r = a + b
                        if i == 1:
                            r = a - b
                        if i == 2:
                            r = a*b
                        if j == 0:
                            r = r + c
                        if j == 1:
                            r = r - c
                        if j == 2:
                            r = r * c
                        if k == 0:
                            r = r + d
                        if k == 1:
                            r = r - d
                        if k == 2:
                            r = r * d
                        if r == e:
                            answer = operators[i]+ operators[j] + operators[k]
                            break
        if "distance" in rec:
            v = int(str(rec[(rec.index("velocity of ")+len("velocity of ")):rec.index(" m/s.")]))
            h = int(str(rec[(rec.index("desk is ")+len("desk is ")):rec.index(" m tall")]))
            t = math.sqrt(h/5)
            answer = int(t*v)
        if "$" in rec:
            cents = float(str(rec[(rec.index("$")+len("$")):rec.index(" purchase")]))
            cents = int(cents*100)
 
            TARGET = cents
            ways = [1] + [0]*TARGET
            #coins = [1, 5, 10, 25, 100, 500]
            coins = []
            if rec.find("pennies") > -1:
                coins.append(1)
            if rec.find("nickels") > -1:
                coins.append(5)
            if rec.find("dimes") > -1:
                coins.append(10)
            if rec.find("quarters") > -1:
                coins.append(25)
            if rec.find(" dollar") > -1:
                coins.append(100)
            if rec.find("five-dollar") > -1:
                coins.append(500)
            if rec.find("ten-dollar") > -1:
                coins.append(1000)
            for coin in coins:
                for i in range(coin, TARGET+1):
                    ways[i] += ways[i-coin]
 
            print "TARGET: "+str(TARGET)
            print "coins: "+str(coins)
            print "rec"+str(rec)
            answer = ways[TARGET]
    
        if "root" in rec:
            #root:386x^2-213072x+26482302
            rec = rec.replace(" ","")
            a = int(str(rec[(rec.index("root:")+len("root:")):rec.index("x^2")]))
            rec = rec.replace("x^2","y^2")
            b = int(str(rec[(rec.index("y^2")+len("y^2")):rec.index("x")]))
            c = int(str(rec[(rec.index("x")+len("x")):len(rec)]))
            x1 = (-b+math.sqrt((b**2)-(4*(a*c))))/(2*a)
            x2 = (-b-math.sqrt((b**2)-(4*(a*c))))/(2*a)
            if "greater" in rec:
                answer = int(max(x1, x2))
            if "lesser" in rec:
                answer = int(min(x1, x2))
 
 
        print (answer)
        attempts = attempts + 1
        print ("attempts: " + str(attempts))
        s.sendall(str(answer))
 
        if not "Solve this problem in" in rec:
            break
            break
```

Here's a breakdown of what is going on:
The script receives each problem as it comes from the server and stores it in `rec`, then determines which type of problem it is by checking `rec` for key phrases:
```python
if "the operations (+, -, or x)" in rec:
if "distance" in rec:
if "$" in rec:
if "root" in rec:
```

Once we know what type of problem we are dealing with, we can appropriately parse the necessary input from `rec` and use mathematical and logical operations to find the solution and send it to the server via the socket, `s`. Each problem is solved differently, but no single problem is exceptionally difficult.

Once we have our script written, we need to get it onto the shell server and run it there otherwise our internet connection might not be fast enough to finish the problems in under 30 seconds.

We do this by logging into the shell and executing the following commands:
```
touch script.py
nano script.py
```

Paste the script in nano, save and close it.

Execute `python script.py` in the shell, and it should work!

**Due to minor bugs in the script, you might need to run it a few times to get the flag. If the program gets stuck on a problem, use the keyboard interrupt Ctrl+C to stop execution**

##Flag: easyctf{A+_for_A+_eff0rt!} 